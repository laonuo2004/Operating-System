#set page(
  margin: (top: 2.54cm, bottom: 2.54cm, left: 3.17cm, right: 3.17cm), // 标准 A4 纸张的上下左右边距
  header: context [
    #align(center, text(14pt, "操作系统课程作业"))
    #v(-1em)
    #line(length: 100%, stroke: 1pt)
  ],
  footer: context [
    #align(center, counter(page).display("1"))
  ],
)
#set text(font: ("Times New Roman", "Source Han Serif SC"), size: 12pt)
#set par(first-line-indent: (amount: 2em, all: true))

// 设置标题样式
#set heading(numbering: (..nums) => {
  let level = nums.pos().len()
  if level == 1 {
    // 一级标题：一、, 二、, 三、...
    numbering("一、", ..nums)
  } else if level == 2 {
    // 二级标题：1.1, 1.2, 1.3...
    let parent = nums.pos().first()
    numbering("1.", parent)
    let current = nums.pos().last()
    numbering("1 ", current)
  }
})

// 设置标题字体与大小
#show heading.where(level: 1): it => {
  set text(size: 14pt, font: "SimHei")
  it
  v(1em)
}

#show heading.where(level: 2): it => {
  set text(size: 14pt, font: "SimHei")
  it
  v(1em)
}

// 设置代码块样式：带背景框、边框和行号
#show raw.where(block: true): it => {
  block(
    width: 100%,
    // fill: luma(245),
    inset: 10pt,
    radius: 4pt,
    stroke: (paint: luma(220), thickness: 1pt),
  )[
    #set par(justify: false)
    #set text(size: 8pt, font: "Consolas")
    #it
  ]
}

// 为代码块添加行号（只在多行代码块中显示）
#show raw.line: it => {
  // 只有当代码块有多行时才显示行号
  if it.count > 1 {
    box(width: 2em, {
      text(fill: luma(120), str(it.number))
      h(0.5em)
    })
    it.body
  } else {
    // 单行代码或行内代码不显示行号
    it.body
  }
}

// 设置行内代码样式：带浅色背景
#show raw.where(block: false): box.with(
  // fill: luma(245),
  inset: (x: 3pt, y: 0pt),
  outset: (y: 3pt),
  radius: 2pt,
  stroke: (paint: luma(220), thickness: 0.5pt),
)

// 缩进函数：输入缩进距离（em），返回带缩进的块
#let indent-block(amount, content) = {
  block(inset: (left: amount))[
    #content
  ]
}

// 实验标题
#let exp-title() = {
  set text(font: "SimHei", size: 18pt)
  align(center, [
    第二章+第三章作业
  ])
}

// 个人信息
#let student_info(class, id, name) = {
  align(center, grid(
    columns: (auto, 6em, auto, 6em, auto, 6em),
    column-gutter: 0.5em,
    "班级:", stack(spacing: 0.5em, align(center, text(class)), line(length: 100%)),
    "学号:", stack(spacing: 0.5em, align(center, text(id)), line(length: 100%)),
    "姓名:", stack(spacing: 0.5em, align(center, text(name)), line(length: 100%)),
  ))
}

// 题目格式化函数：题号固定宽度，正文自动对齐
#let problem(num, content) = {
  grid(
    columns: (1.5em, 1fr),
    column-gutter: 1em,
    align: (left, left),
    [*#num*],
    content
  )
}

// 答案格式化函数：统一的答案样式
#let answer(content) = {
  block(
    width: 100%,
    fill: luma(250),
    inset: (x: 1em, y: 0.8em),
    radius: 3pt,
    stroke: (paint: luma(200), thickness: 0.5pt),
  )[
    #set par(first-line-indent: 0em)
    #set text(size: 12pt)
    #grid(
      columns: (auto, 1fr),
      column-gutter: 0.5em,
      align: (left, left),
      [*答：*],
      content
    )
  ]
}

#exp-title()

#student_info("07112303", "1120231863", "左逸龙")

#v(2em)

#problem("2-9", [有五个作业正等待运行，它们估计运行时间分别为9、6、3、5和$x$。为了获得最小的平均周转时间，应按照什么顺序运行它们？（你给出的答案应是$x$的函数）。])

#v(1em)

#answer([
为了使平均周转时间最短，应采用"最短作业优先调度法"，即总是优先运行作业时间最短的作业。

对5个作业分别编号为 $1~5$，则运行顺序：
$ cases(
    5 -> 3 -> 4 -> 2 -> 1 (0 < x <= 3),
    3 -> 5 -> 4 -> 2 -> 1 (3 < x <= 5),
    3 -> 4 -> 5 -> 2 -> 1 (5 < x <= 6),
    3 -> 4 -> 2 -> 5 -> 1 (6 < x <= 9),
    3 -> 4 -> 2 -> 1 -> 5 (x > 9)
  ) $
])

#v(2em)

#problem("2-12", [假定系统有四道作业，它们的提交时间及估计执行时间（以小时为单位）如下表所示。在单道批处理系统中，采用先来先服务、最短作业优先和响应比高者优先的调度算法时，分别计算下表列出作业的平均周转时间。])

#table(
  columns: (5em, 1fr, 1fr),
  align: center,
  stroke: 1pt,
  table.header(
    [*作业号*],
    [*提交时间（小时）*],
    [*估计运行时间（小时）*]
  ),
  [1], [8.0], [2.0],
  [2], [9.0], [1.2],
  [3], [9.5], [0.5],
  [4], [10.2], [0.3]
)

#v(1em)

#answer([
*① 先来先服务（FCFS）：*

1. 8.0时：作业1到达，开始运行
2. 9.0时：作业2到达，等待调度
3. 9.5时：作业3到达，等待调度
4. 10.0时：作业1完成，开始运行作业2
5. 10.2时：作业4到达，等待调度
6. 11.2时：作业2完成，开始运行作业3
7. 11.7时：作业3完成，开始运行作业4
8. 12.0时：作业4完成

平均周转时间 = $((10-8) + (11.2-9) + (11.7-9.5) + (12-10.2)) / 4 = 2.05$（时）

*② 最短作业优先（SJF）：*

1. 8.0时：作业1到达，开始运行
2. 9.0时：作业2到达，等待调度
3. 9.5时：作业3到达，等待调度
4. 10.0时：作业1完成，由于 $0.5 < 1.2$，故开始运行作业3
5. 10.2时：作业4到达，等待调度
6. 10.5时：作业3完成，由于 $0.3 < 1.2$，故开始运行作业4
7. 10.8时：作业4完成，开始运行作业2
8. 12.0时：作业2完成

平均周转时间 = $((10-8) + (12-9) + (10.5-9.5) + (10.8-10.2)) / 4 = 1.65$（时）

*③ 响应比高者优先（HRRN）：*

1. 8.0时：作业1到达，开始运行
2. 9.0时：作业2到达，等待调度
3. 9.5时：作业3到达，等待调度
4. 10.0时：作业1完成，计算响应比：
   - $text("RP")_2 = 1 + (10-9) / 1.2 = 11/6$
   - $text("RP")_3 = 1 + (10-9.5) / 0.5 = 2$
   - 由于 $2 > 11/6$，故开始运行作业3
5. 10.2时：作业4到达，等待调度
6. 10.5时：作业3完成，计算响应比：
   - $text("RP")_2 = 1 + (10.5-9) / 1.2 = 2.25$
   - $text("RP")_4 = 1 + (10.5-10.2) / 0.3 = 2$
   - 由于 $2.25 > 2$，故开始运行作业2
7. 11.7时：作业2完成，开始运行作业4
8. 12.0时：作业4完成

平均周转时间 = $((10-8) + (11.7-9) + (10.5-9.5) + (12-10.2)) / 4 = 1.875$（时）
])

#v(2em)

#problem("2-13", [有五个批处理作业A、B、C、D、E，它们几乎同时到达计算中心。它们估计运行时间分别为10、6、2、4、8分钟。它们的优先级分别为3、5、2、1、4，其中5为最高优先级。这些作业都是纯计算型作业。一次只运行一个作业，直到它完成。对于下面列出的调度算法，忽略调度本身的开销，计算作业进程的平均周转时间。])

#indent-block(0.5em, [
(1) 轮转法（时间片为2分钟，按A、B、C、D、E的顺序轮转）。

(2) 优先级调度法。
])

#v(1em)

#answer([
(1) 轮转法

① 第1次轮转：作业C完成，周转时间 = $2 times 3 = 6$（分钟）。轮转总用时 10 分钟。

② 第2次轮转：作业D完成，周转时间 = $10 + 2 times 3 = 16$（分钟）。轮转总用时 8 分钟。

③ 第3次轮转：作业B完成，周转时间 = $10 + 8 + 2 times 2 = 22$（分钟）。轮转总用时 6 分钟。

④ 第4次轮转：作业E完成，周转时间 = $10 + 8 + 6 + 2 times 2 = 28$（分钟）。轮转总用时 4 分钟。

⑤ 第5次轮转：作业A完成，周转时间 = $10 + 8 + 6 + 4 + 2 times 1 = 30$（分钟）。

平均周转时间 = $(6 + 16 + 22 + 28 + 30) / 5 = 20.4$（分钟）。

(2) 优先级调度法

运行顺序：B → E → A → C → D

各作业周转时间：

A: $6 + 8 + 10 = 24$（分钟）

B: $6$（分钟）

C: $6 + 8 + 10 + 2 = 26$（分钟）

D: $6 + 8 + 10 + 2 + 4 = 30$（分钟）

E: $6 + 8 = 14$（分钟）

平均周转时间 = $(24 + 6 + 26 + 30 + 14) / 5 = 20$（分钟）。
])

#v(2em)

#problem("3-7", [设系统有$n+1$个进程，其中有$n$个发送进程和1个接收进程。$A_1$、$A_2$、…、$A_n$通过一个单缓冲区分别不断地向进程$B$发消息，$B$不断地取走缓冲区中的消息，而且必须取走发来的每一个消息。刚开始时，缓冲区为空。试用P、V操作正确实现进程之间的同步。])

#v(1em)

#answer([
该问题可以一般化为生产者-消费者问题。$n$ 个发送进程为生产者，接收进程 $B$ 为消费者。它们共享单缓冲区。

*（1）定义信号量与缓冲区：*

```c
semaphore mutex = 1, empty = 1, full = 0;
message buffer, x, y;
```

*（2）定义发送进程 $A_i$ ($i = 1, 2, ..., n$)操作：*

```c
while (true) {
    produce_message(x);
    P(empty);
    P(mutex);
    buffer = x;
    V(mutex);
    V(full);
}
```

*（3）定义接收进程 $B$ 操作：*

```c
while (true) {
    P(full);
    P(mutex);
    y = buffer;
    V(mutex);
    V(empty);
    consume_message(y);
}
```

其中 `mutex` 用于实现互斥访问，`empty` 和 `full` 用于实现同步控制。
])

#v(2em)

#problem("3-8", [有一容量为$100$的循环缓冲区，有多个并发执行进程通过该缓冲区进行通信。为了正确地管理缓冲区，系统设置了两个读写指针分别为$text("OUT")$、$text("IN")$。$text("IN")$和$text("OUT")$的值如何反映缓冲区为空还是满的情况？])

#v(1em)

#answer([
循环缓冲区使用 $text("IN")$ 指向下一个可写入位置，$text("OUT")$ 指向下一个可读取位置。我们可以使用以下两式来判断缓冲区为空还是满：

- *缓冲区为空*：$text("IN") == text("OUT")$
- *缓冲区为满*：$(text("IN") + 1) mod 100 == text("OUT")$
])

#v(2em)

#problem("3-9", [有一阅览室，共有$100$个座位。为了很好地利用它，读者进入时必须先在登记表上进行登记，该表表目设有座位号和读者姓名，离开时再将其登记项擦除。试问：])

#indent-block(0.5em, [
(1) 为描述读者的动作，应编写几个程序？应设几个进程？它们之间的关系是什么？

(2) 试用P、V操作描述读者之间的同步算法。
])

#v(1em)

#answer([
*(1)* 应编写*一个*程序 (所有读者行为逻辑相同)，设置*多个*进程（每个读者对应一个进程）。一方面，它们之间是*同步关系*，共享阅览室座位和登记表资源；另一方面，它们之间是*互斥关系*，需要*互斥访问*登记表。

*(2)* P、V操作描述如下：

*定义信号量：*

```c
semaphore seats = 100;
semaphore mutex = 1;
```

*读者进程：*

```c
P(seats);
P(mutex);
在登记表上登记();
V(mutex);
阅读();
P(mutex);
擦除登记();
V(mutex);
V(seats);
```

其中 `seats` 控制座位数量，`mutex` 保证对登记表的互斥访问。
])

#v(2em)

#problem("3-14", [假定系统有$N$个进程共享$M$个同类资源，规定每个进程至少申请一个资源，每个进程的最大需求不超过$M$，所有进程的需求总和小于$M+N$。为什么在这种情况下也决不会发生死锁？试证明。])

#v(1em)

#answer([
使用反证法证明。

设每个进程的最大需求为 $p_i$，由题意知 $sum_(i=1)^N p_i < M + N$ ①。

假设发生死锁，则所有进程都处于阻塞态，没有任一进程完成。因为倘若存在某个进程完成了，那么剩余的资源会更多，更不可能发生死锁。因此只有可能刚开始便发生了死锁，此时所有进程都处于阻塞态。设各进程的实际资源分配数为 $q_i$，则：

- $sum_(i=1)^N q_i = M$ ②（所有资源都分配完了）
- $q_i < p_i$ $(1 <= i <= N)$ ③（每个进程都还需要资源，所以被阻塞）

由③得：$q_i + 1 <= p_i$ $(1 <= i <= N)$ ④

由④得：$sum_(i=1)^N p_i >= sum_(i=1)^N (q_i + 1) = sum_(i=1)^N q_i + N$ ⑤

将②代入⑤得：$sum_(i=1)^N p_i >= M + N$ ⑥，与①矛盾，假设不成立。

因此，在这种情况下决不会发生死锁。
])

#v(2em)

// 3-15题：左边题目，右边预留图片位置
#grid(
  columns: (2fr, 1fr),
  column-gutter: 2em,
  align: (left, center),
  [
    #problem("3-15", [设有$8$个进程$M_1$、$M_2$、…、$M_8$，它们有如右图所示的优先关系，试用P、V操作实现这些进程间的同步。])
  ],
  [
    // 预留图片位置
    #figure(
      image("images/3-15.png", height: 10%),
    )
  ]
)

#v(1em)

#answer([
*定义信号量：*

```c
semaphore a1 = 0, a2 = 0, a3 = 0, a4 = 0, a5 = 0, a7 = 0;
```

*各进程操作：*

```c
M1() {
    执行M1();
    V(a1); V(a1); V(a1);  // 重复执行3次是因为后面有3次P(a1)，每次都会-1
}

M2() {
    P(a1);
    执行M2();
    V(a2);
}

M3() {
    P(a1);
    执行M3();
    V(a3); V(a3);
}

M4() {
    P(a1);
    执行M4();
    V(a4);
}

M5() {
    执行M5();
    V(a5);
}

M6() {
    P(a2); P(a3);
    执行M6();
}

M7() {
    P(a4); P(a5);
    执行M7();
    V(a7);
}

M8() {
    P(a3); P(a7);
    执行M8();
}
```
])

#v(2em)

#problem("3-16", [设有$5$个哲学家，共享一张放有$5$把椅子的圆桌。每人分得$1$把椅子。但是，桌子上总共只有$5$把叉子。哲学家们在肚子饥饿时才试图分两次从两边捡起$2$把叉子就餐。条件：])

#indent-block(0.5em, [
a. 每人只有拿到$2$把叉子时，哲学家才能吃饭。

b. 如果叉子已在他人手上，则该哲学家必须等到他人吃完之后才能拿到叉子。

c. 任性的哲学家在自己未拿到$2$把叉子吃饭之前，决不放下自己手中的叉子。

试问：

(1) 什么情况下$5$个哲学家全部吃不上饭？

(2) 描述一种避免有人饿死（永远拿不到$2$个叉子）的算法。
])

#v(1em)

#answer([
*(1)* 当每个哲学家都拿起$1$把叉子时，$5$把叉子全部被占用，但没有人能拿到$2$把叉子，所有哲学家都处于等待状态，形成死锁，导致全部吃不上饭。

*(2)* 使用限制同时就餐人数的方法避免死锁：

*定义信号量：*

```c
semaphore fork[5] = {1, 1, 1, 1, 1};
semaphore room = 4;  // 最多允许4个哲学家同时就餐
```

*哲学家$i$ ($i = 0, 1, 2, 3, 4$)的操作：*

```c
philosopher_i() {
    while (true) {
        P(room);
        P(fork[i]);
        P(fork[(i+1) mod 5]);
        就餐();
        V(fork[(i+1) mod 5]);
        V(fork[i]);
        V(room);
    }
}
```
])

#v(2em)

#problem("3-17", [在本章前面的读者与写者问题中，是用读者优先解决问题的。试分别用读者与写者公平竞争（无写者时，读者仍遵循多个读者可以同时读）、写者优先的算法解决这个问题。])

#v(1em)

#answer([
*(1) 读者与写者公平竞争算法：*

*定义信号量：*

```c
semaphore rmutex = 1, wmutex = 1;
semaphore queue = 1;  // 公平竞争的信号量
int readcount = 0;
```

*读者进程：*

```c
P(queue);
P(rmutex);
if (readcount == 0) P(wmutex);
readcount++;
V(rmutex);
V(queue);
读文件();
P(rmutex);
readcount--;
if (readcount == 0) V(wmutex);
V(rmutex);
```

*写者进程：*

```c
P(queue);
P(wmutex);
写文件();
V(wmutex);
V(queue);
```

通过 `queue` 信号量确保读者和写者按到达顺序竞争，实现公平竞争。

*(2) 写者优先算法：*

*定义信号量：*

```c
semaphore rmutex = 1, wmutex = 1;
semaphore resource = 1;  // 保护文件资源
semaphore r = 1;  // 阻止新读者在有写者等待时进入
int readcount = 0, writecount = 0;
```

*读者进程：*

```c
P(r);
P(rmutex);
if (readcount == 0) P(resource);
readcount++;
V(rmutex);
V(r);
读文件();
P(rmutex);
readcount--;
if (readcount == 0) V(resource);
V(rmutex);
```

*写者进程：*

```c
P(wmutex);
writecount++;
if (writecount == 1) P(r);
V(wmutex);
P(resource);
写文件();
V(resource);
P(wmutex);
writecount--;
if (writecount == 0) V(r);
V(wmutex);
```
])

#v(2em)

#problem("3-18", [有一个理发师、一把理发椅和$n$把供等候理发的顾客坐的椅子。如果没有顾客，则理发师便坐在椅子上睡觉，当一个顾客到来时，必须唤醒理发师，请求理发；如果理发师正在理发时，又有顾客来到，只要有空椅子，他就坐下来等待，如果没有空椅子，他就离开。请为理发师和顾客各编写一段程序来描述他们的同步过程。])

#v(1em)

#answer([
*定义信号量：*

```c
semaphore customers = 0;  // 等待理发的顾客数量
semaphore barber = 0;     // 理发师是否准备好
semaphore mutex = 1;      // 保护等待室访问
int waiting = 0;          // 等待理发的顾客数量。这个变量用于与 n 比较，
                          // 和信号量作用有所不同，虽然理论上值是一样的
```

*理发师进程：*

```c
while (true) {
    P(customers);       // 等待顾客，如果没有顾客则睡觉
    P(mutex);
    waiting--;
    V(barber);          // 通知顾客理发师准备好
    V(mutex);
    理发();
}
```

*顾客进程：*

```c
P(mutex);
if (waiting < n) {
    waiting++;
    V(customers);       // 通知理发师有顾客
    V(mutex);
    P(barber);          // 等待理发师准备好
    理发();
} else {
    V(mutex);           // 没有空椅子，离开
}
```
])

#v(2em)

#problem("3-19", [假定系统中只有一类资源，进程一次只申请一个单位的资源，且进程申请的资源数不会超过系统拥有的资源总数。假定进程申请的资源总数为2，且系统资源总数如下，问下列哪些情况会发生死锁？])

#table(
  columns: (auto, 1fr, 1fr, auto, 1fr, 1fr),
  align: center,
  stroke: 1pt,
  table.header(
    [*情况*],
    [*进程数*],
    [*系统资源总数*],
    [*情况*],
    [*进程数*],
    [*系统资源总数*]
  ),
  [(1)], [1], [2], [(4)], [3], [3],
  [(2)], [2], [2], [(5)], [3], [5],
  [(3)], [2], [3], [(6)], [4], [5]
)

#v(1em)

#answer([
每个进程最多需要$2$个资源。死锁发生的条件是：所有进程都持有部分资源但无法获得全部所需资源。

设进程数为$N$，系统资源总数为$M$。在最坏情况下，每个进程都获得了$1$个资源，此时：
- 已分配资源数 = $N$
- 剩余资源数 = $M - N$
- 每个进程还需要$1$个资源

若$M - N < 1$，即$M <= N$，则剩余资源不足以满足任何进程的需求，可能发生死锁。

分析各情况：

*(1)* $N=1$，$M=2$：$M > N$，不会死锁。

*(2)* $N=2$，$M=2$：$M = N$，可能死锁。

*(3)* $N=2$，$M=3$：$M > N$，不会死锁。

*(4)* $N=3$，$M=3$：$M = N$，可能死锁。

*(5)* $N=3$，$M=5$：$M > N$，不会死锁。

*(6)* $N=4$，$M=5$：$M > N$，不会死锁。

因此，会发生死锁的情况是：*(2)*、*(4)*。
])

#v(2em)

#problem("3-20", [某一系统有$10$个同类资源，有$3$个进程$P_1$、$P_2$、$P_3$，它们对资源的最大需求量分别为$8$、$6$、$7$。它们的资源使用序列和数量如下图所示。])

#indent-block(0.5em, [
(1) 试给出采用银行家算法分配资源时，进行第5次分配后各进程的状态及各进程占用资源情况。

(2) 在以后的申请中，哪次的申请可以得到最先满足？给出一个进程完成序列。
])

#table(
  columns: (auto, 1fr, 1fr, auto, 1fr, 1fr),
  align: center,
  stroke: 1pt,
  table.header(
    [*次序*],
    [*进程*],
    [*申请量*],
    [*次序*],
    [*进程*],
    [*申请量*]
  ),
  [1], [P1], [3], [5], [P2], [2],
  [2], [P2], [2], [6], [P1], [3],
  [3], [P3], [4], [7], [P3], [4],
  [4], [P1], [2], [8], [P2], [2]
)

#v(1em)

#answer([
初始状态：可用资源 = $10$，各进程已分配 = $0$，各进程还需 = 最大需求。

*第1次分配：* P1申请$3$
- 检查申请量：$3 <= 10$（可用），$3 <= 8$（最大需求）
- 假设分配后：P1已分配$3$，还需$5$；Available = $7$
- 寻找安全序列：
  - P2：Need=$6 <=$ Available=$7$，可满足，完成后Available=$7+0=7$（P2未分配）
  - P3：Need=$7 <=$ Available=$7$，可满足，完成后Available=$7+0=7$（P3未分配）
  - P1：Need=$5 <=$ Available=$7$，可满足，完成后Available=$7+3=10$
  - 安全序列：P2 → P3 → P1，系统安全，*允许分配*

*第2次分配：* P2申请$2$
- 检查申请量：$2 <= 7$（可用），$2 <= 6$（最大需求）
- 假设分配后：P1已分配$3$，P2已分配$2$，P3已分配$0$；Available = $5$
- 寻找安全序列：
  - P2：Need=$4 <=$ Available=$5$，可满足，完成后Available=$5+2=7$
  - P3：Need=$7 <=$ Available=$7$，可满足，完成后Available=$7+0=7$（P3未分配）
  - P1：Need=$5 <=$ Available=$7$，可满足，完成后Available=$7+3=10$
  - 安全序列：P2 → P3 → P1，系统安全，*允许分配*

*第3次分配：* P3申请$4$
- 检查申请量：$4 <= 5$（可用），$4 <= 7$（最大需求）
- 假设分配后：P3已分配$4$，还需$3$；可用资源 = $1$
- 寻找安全序列：
  - P1：Need=$5 >$ Available=$1$，不满足
  - P2：Need=$4 >$ Available=$1$，不满足
  - P3：Need=$3 >$ Available=$1$，不满足
  - 无法找到安全序列，系统不安全，*拒绝分配*

*第4次分配：* P1申请$2$
- 检查申请量：$2 <= 5$（可用），$2 <= 5$（还需）
- 假设分配后：P1已分配$5$，P2已分配$2$，P3已分配$0$；Available = $3$
- 寻找安全序列：
  - P1：Need=$3 <=$ Available=$3$，可满足，完成后Available=$3+5=8$
  - P2：Need=$4 <=$ Available=$8$，可满足，完成后Available=$8+2=10$
  - P3：Need=$7 <=$ Available=$10$，可满足，完成后Available=$10+0=10$
  - 安全序列：P1 → P2 → P3，系统安全，*允许分配*

*第5次分配：* P2申请$2$
- 检查申请量：$2 <= 3$（可用），$2 <= 4$（还需）
- 假设分配后：P2已分配$4$，还需$2$；可用资源 = $1$
- 寻找安全序列：
  - P1：Need=$3 >$ Available=$1$，不满足
  - P2：Need=$2 >$ Available=$1$，不满足
  - P3：Need=$7 >$ Available=$1$，不满足
  - 无法找到安全序列，系统不安全，*拒绝分配*

*(1) 第5次分配后各进程状态：*

#table(
  columns: (auto, auto, auto, auto, auto),
  align: center,
  stroke: 1pt,
  table.header([*进程*], [*状态*],[*已分配*], [*还需*], [*最大需求*]),
  [P1], [未完成], [$5$], [$3$], [$8$],
  [P2], [未完成], [$2$], [$4$], [$6$],
  [P3], [未完成], [$0$], [$7$], [$7$]
)

可用资源 = $3$。

*(2) 后续申请分析：*

当前状态：Available = $3$，P1已分配$5$还需$3$，P2已分配$2$还需$4$，P3已分配$0$还需$7$。

*第6次申请：* P1申请$3$
- 检查：$3 <= 3$（可用），$3 <= 3$（还需）
- 假设分配后：P1已分配$8$，P2已分配$2$，P3已分配$0$；Available = $0$
- 寻找安全序列：
  - P1：Need=$0 <=$ Available=$0$，可满足，完成后Available=$0+8=8$
  - P2：Need=$4 <=$ Available=$8$，可满足，完成后Available=$8+2=10$
  - P3：Need=$7 <=$ Available=$10$，可满足，完成后Available=$10+0=10$
  - 安全序列：P1 → P2 → P3，*可以满足*

因此，*第6次申请（P1申请$3$）* 可以最先得到满足，此时完成序列为：P1 → P2 → P3。
])

#v(2em)

#problem("3-21", [考虑某一系统，它有$4$类资源$R_1$、$R_2$、$R_3$、$R_4$，有$5$个并发进程$P_0$、$P_1$、$P_2$、$P_3$、$P_4$。请按照银行家算法回答下列问题：])

#indent-block(0.5em, [
(1) 各进程的最大资源请求和已分配的资源矩阵及系统当前的剩余资源向量如下图所示，计算各进程的剩余资源请求向量组成的矩阵。

(2) 系统当前处于安全状态吗？

(3) 当进程$P_2$申请的资源分别为$(1, 0, 0, 1)$时，系统能立即满足吗？
])

#table(
  columns: (auto, 1fr, 1fr, 1fr, 1fr, 1fr, 1fr, 1fr, 1fr),
  align: center,
  stroke: 1pt,
  table.cell(rowspan: 2, align: center, inset: (top: 40%))[*进程*],
  table.cell(colspan: 4, align: center)[*分配向量*],
  table.cell(colspan: 4, align: center)[*最大需求量*],
  [*R1*], [*R2*], [*R3*], [*R4*], [*R1*], [*R2*], [*R3*], [*R4*],
  [P0], [0], [0], [1], [2], [0], [0], [1], [2],
  [P1], [1], [0], [0], [0], [1], [7], [5], [0],
  [P2], [1], [3], [5], [4], [2], [3], [5], [6],
  [P3], [0], [6], [3], [2], [0], [6], [5], [2],
  [P4], [0], [0], [1], [4], [0], [6], [5], [6]
)

#v(1em)

#table(
  columns: (1fr, 1fr, 1fr, 1fr),
  align: center,
  stroke: 1pt,
  table.header(
    [*R1*],
    [*R2*],
    [*R3*],
    [*R4*]
  ),
  [1], [5], [0], [2]
)

#align(center)[*当前剩余资源向量*]

#v(1em)

#answer([
*(1) 计算剩余资源请求向量（Need矩阵）：*

Need = Max - Allocation

#table(
  columns: 5,
  [进程], [R1], [R2], [R3], [R4],
  [P0], [$0-0=0$], [$0-0=0$], [$1-1=0$], [$2-2=0$],
  [P1], [$1-1=0$], [$7-0=7$], [$5-0=5$], [$0-0=0$],
  [P2], [$2-1=1$], [$3-3=0$], [$5-5=0$], [$6-4=2$],
  [P3], [$0-0=0$], [$6-6=0$], [$5-3=2$], [$2-2=0$],
  [P4], [$0-0=0$], [$6-0=6$], [$5-1=4$], [$6-4=2$],
)

*(2) 检查系统是否处于安全状态：*

当前可用资源向量：Available = $(1, 5, 0, 2)$

寻找安全序列：
- P0：Need$(0,0,0,0) <=$ Available$(1,5,0,2)$，可满足。完成后释放$(0,0,1,2)$，Available = $(1,5,1,4)$
- P2：Need$(1,0,0,2) <=$ Available$(1,5,1,4)$，可满足。完成后释放$(1,3,5,4)$，Available = $(2,8,6,8)$
- P3：Need$(0,0,2,0) <=$ Available$(2,8,6,8)$，可满足。完成后释放$(0,6,3,2)$，Available = $(2,14,9,10)$
- P1：Need$(0,7,5,0) <=$ Available$(2,14,9,10)$，可满足。完成后释放$(1,0,0,0)$，Available = $(3,14,9,10)$
- P4：Need$(0,6,4,2) <=$ Available$(3,14,9,10)$，可满足。

存在安全序列：P0 → P2 → P3 → P1 → P4，系统处于*安全状态*。

*(3) 当P2申请$(1, 0, 0, 1)$时：*

① 检查申请是否超过Need：$(1,0,0,1) <= (1,0,0,2)$，满足。

② 检查申请是否超过Available：$(1,0,0,1) <= (1,5,0,2)$，满足。

③ 假设分配，更新状态：
- Available = $(1,5,0,2) - (1,0,0,1) = (0,5,0,1)$
- P2 Allocation = $(1,3,5,4) + (1,0,0,1) = (2,3,5,5)$
- P2 Need = $(1,0,0,2) - (1,0,0,1) = (0,0,0,1)$

④ 检查分配后是否安全：
- P0：Need$(0,0,0,0) <=$ Available$(0,5,0,1)$，可满足。完成后Available = $(0,5,1,3)$
- P2：Need$(0,0,0,1) <=$ Available$(0,5,1,3)$，可满足。完成后Available = $(2,8,6,8)$
- P3：Need$(0,0,2,0) <=$ Available$(2,8,6,8)$，可满足。完成后Available = $(2,14,9,10)$
- P1：Need$(0,7,5,0) <=$ Available$(2,14,9,10)$，可满足。完成后Available = $(3,14,9,10)$
- P4：Need$(0,6,4,2) <=$ Available$(3,14,9,10)$，可满足。

存在安全序列：P0 → P2 → P3 → P1 → P4，分配后仍处于安全状态。

因此，*系统能立即满足P2的申请*。
])

#v(2em)